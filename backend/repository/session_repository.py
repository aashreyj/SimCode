from sqlalchemy.orm import Session, joinedload
from fastapi import HTTPException, status
from domain import models
from datetime import datetime, timedelta
import json

class SessionRepository:
    @staticmethod
    def get_session_by_id(db: Session, session_id: str):
        """Retrieve a session by its ID with participants loaded"""
        return db.query(models.Session).options(
            joinedload(models.Session.participants)
        ).filter(models.Session.session_id == session_id).first()
    
    @staticmethod
    def get_sessions_by_user(db: Session, user_id: str):
        """Get all sessions where a user is a participant"""
        # First get all participant entries for this user
        participant_entries = db.query(models.SessionParticipant).filter(
            models.SessionParticipant.user_id == user_id
        ).all()
        
        # Then get the session IDs
        session_ids = [p.session_id for p in participant_entries]
        
        # Finally get all those sessions with their participants
        if session_ids:
            return db.query(models.Session).options(
                joinedload(models.Session.participants)
            ).filter(models.Session.session_id.in_(session_ids)).all()
        return []
    
    @staticmethod
    def create_session(db: Session, session_data, host_user_id: str):
        """Create a new session and add the host as first participant"""
        # Create session
        new_session = models.Session(
            session_id=session_data.get("session_id", None),
            document_id=session_data["document_id"],
            host_user_id=host_user_id,
            name=session_data.get("name"),
            max_participants=session_data.get("max_participants", 10),
            is_public=session_data.get("is_public", True),
            session_timeout=session_data.get("session_timeout", 60)
        )
        
        db.add(new_session)
        db.flush()  # Flush to get the session ID if it was generated by the database
        
        # Add host as participant
        host_participant = models.SessionParticipant(
            session_id=new_session.session_id,
            user_id=host_user_id,
            role=models.UserRole.HOST,
        )
        
        db.add(host_participant)
        db.commit()
        db.refresh(new_session)
        
        return new_session
    
    @staticmethod
    def update_session(db: Session, session, update_data):
        """Update session properties"""
        for key, value in update_data.items():
            if value is not None and hasattr(session, key):
                if key == "status" and isinstance(value, str):
                    setattr(session, key, models.SessionStatus(value))
                else:
                    setattr(session, key, value)
        
        session.last_activity = datetime.now()
        db.commit()
        db.refresh(session)
        return session
    
    @staticmethod
    def delete_session(db: Session, session):
        """Delete a session and all its participants"""
        db.delete(session)
        db.commit()
        return True
    
    @staticmethod
    def get_participant(db: Session, session_id: str, user_id: str):
        """Get a specific participant in a session"""
        return db.query(models.SessionParticipant).filter(
            models.SessionParticipant.session_id == session_id,
            models.SessionParticipant.user_id == user_id
        ).first()
    
    @staticmethod
    def create_participant(db: Session, session_id: str, user_data):
        """Add a new participant to a session"""
        new_participant = models.SessionParticipant(
            session_id=session_id,
            user_id=user_data["user_id"],
            role=models.UserRole(user_data["role"]),
        )
        
        db.add(new_participant)
        db.commit()
        db.refresh(new_participant)
        return new_participant

    @staticmethod
    def remove_participant(db: Session, participant):
        """Remove a participant from a session"""
        db.delete(participant)
        db.commit()
        return True
    
    @staticmethod
    def update_participant(db: Session, participant, update_data):
        """Update a participant's properties"""
        for key, value in update_data.items():
            if value is not None and hasattr(participant, key):
                if key == "role" and isinstance(value, str):
                    setattr(participant, key, models.UserRole(value))
                else:
                    setattr(participant, key, value)
        
        participant.last_active = datetime.now()
        db.commit()
        db.refresh(participant)
        return participant
    
    @staticmethod
    def get_inactive_sessions(db: Session):
        """Get sessions that have been inactive longer than their timeout"""
        now = datetime.now()
        inactive_sessions = []
        
        # Get all active sessions
        active_sessions = db.query(models.Session).filter(
            models.Session.status == models.SessionStatus.ACTIVE
        ).all()
        
        for session in active_sessions:
            # Calculate timeout threshold
            timeout_threshold = session.last_activity + timedelta(minutes=session.session_timeout)
            
            # If session has been inactive longer than timeout, mark it
            if now > timeout_threshold:
                inactive_sessions.append(session)
                
        return inactive_sessions